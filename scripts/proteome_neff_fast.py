#!/usr/bin/env python3

import sys
import os
import subprocess as sp
from tqdm import tqdm
import argparse

parser = argparse.ArgumentParser(
  description="generate per-residue Neff scores blazingly fast on the GPU",
)
parser.add_argument(
  "-f", "--source-file", type=str, metavar="SRC",
  default="./data/UP000005640_9606.tar",
  help="specify a source to load MSAs from. this can be\n(1) either a folder with .a3ms in it or\n"
       "(2) a .tar or .tar.gz archive (.tar.gz is slow, therefore not recommended). if an archive "
       "is specified, the .a3m files are expected to be in a subfolder and can be found using "
       "this path: \n f\"{PROTEOME_NAME}/msas/{protein_name}.a3m\" inside the archive. "
       "default filename is %(default)s",
)
parser.add_argument(
  "-o", "--out-dir", type=str, metavar="OUTDIR",
  default="./data/test",
  help="specify a directory, .tar, or .tar.gz archive that will contain output generated by "
       "this utility. this includes a .json file for each protein present in the SRC. also, "
       " a failed.txt file is written that contains (line-seperated) protein IDs that NEFFF "
       "failed to process. (potenially due to CUDA OOM or other errors.) "
       "default directory is %(default)s",
)
parser.add_argument(
  "-n", "--neff-fast", "--nefffast", type=str, metavar="NEFFF",
  default="./scripts/neff_gpu.py",
  help="specify the script that actually generates the Neff scores for each protein. (default "
       "script path %(default)s)",
)
parser.add_argument(
  "-d", "--device", type=str, metavar="DEVICE", default="cuda", 
  help="device passed to NEFFF, can be cuda, cpu, or any other valid pytorch "
       "device. (default is %(default)s)"
)
parser.add_argument(
  "-b", "--batch-size", "--batchsize", type=int, metavar="B", default=2**12,
  help="batch size passed to NEFFF, set to high number (>2**14) if much gpu memory "
       "is available and to lower value if not so much memory is available (<2**12)."
)
parser.add_argument(
  "-l", "--gpu-mem-limit", type=str, metavar="M", default=None,
  help="gpu memory size limit, passed to NEFFF. (see NEFFF documentation for details)"
)
parser.add_argument(
  "-p", "--proteome-name", "--proteome", type=str, metavar="P", default="infer",
  help="optionally specify the proteome name. set to \"infer\" to try to infer the PROTEOME_NAME "
       "from the archive name. this is used to locate the folder containing the \"/msas/\" "
       " subfolder containing the .a3ms inside the archive. see the --source-file option. (for "
       "folder-based SRC, this option is not relevant.)"
)
args = parser.parse_args()

# extract protein names from archive or folder
srcmode = "archive" if any(args.source_file.endswith(t) for t in [".tar",".tar.gz"]) else "dir"
if srcmode == "archive":
  tar_protein_filenames = sp.run(
    f"tar -tf {args.source_file}", 
    shell=True,
    capture_output=True,
  )
  assert tar_protein_filenames.returncode == 0, "failed to get protein names"
  tar_stdout_lines = tar_protein_filenames.stdout.decode("ascii").splitlines()
  src_protein_names = [
    os.path.splitext(os.path.basename(n))[0]
    for n in tar_stdout_lines if "/msas/" in n and n.endswith(".a3m")
  ]

  # if proteome name is infer, try to to infer the proteome name from the archive
  if args.proteome_name == "infer":
    # NB: this is a very hacky way. tar -t probably works the same on a lot of linux machines, 
    # but does it guarantee that the order of outputs? in the following line, it is required that
    # the first output line of tar -t is the base directory containing all the MSAs. right of the 
    # bat, I can imagine 1000&1 ways how this can go wrong.
    args.proteome_name = tar_stdout_lines[0][:-1]
    print("tried to infer proteome name:", args.proteome_name)
elif srcmode == "dir":
  # try to load proteins from folder
  src_protein_names = [
    os.path.splitext(os.path.basename(n))[0] 
    for n in os.listdir(args.source_file) if n.endswith(".a3m")
  ]
else:
  raise ValueError("unable to determine source file type")

# sanity ck proteome_name
if args.proteome_name == "infer":
  args.proteome_name = None # don't have proteome_name="infer" flying around in this app

# see which proteins have already been processed
dstmode = "archive" if any(args.out_dir.endswith(t) for t in [".tar",".tar.gz"]) else "dir"
if dstmode == "dir":
  existing_protein_names = [
    os.path.splitext(os.path.basename(n))[0]
    for n in os.listdir(args.out_dir)
  ]
elif dstmode == "archive":
  existing_protein_names = []
  if os.path.exists(args.out_dir):
    # get already processed protein names from tar file
    res = sp.run(f"tar -tf {args.out_dir}", shell=True, capture_output=True)
    assert res.returncode == 0, (
      "failed to get already processed protein names from archive %s" % args.out_dir
    )
    existing_protein_names = [
      os.path.splitext(os.path.basename(n))[0]
      for n in res.stdout.decode().split()
    ]
  else:
    # create empty archive
    res = sp.run(f"tar -cf {args.out_dir} -T /dev/null", shell=True)
    assert res.returncode == 0, "failed to create output archive %s" % args.out_dir
else:
  raise ValueError("unable to determine destination file type")
print(f"found {len(existing_protein_names)} already processed proteins")

to_process = list(set(src_protein_names) - set(existing_protein_names))
print(f"{len(to_process)} proteins need to be processed")

# run Neff calculation for each file
num_success,num_failed = 0,0
for protein_name in (pbar := tqdm(to_process)):
  pbar.set_description("Neff'ing %s, %dP, %dF" % (protein_name, num_success,num_failed))
  
  # these should always be passed to NEFFFAST, no matter where the input comes from or the 
  # output goes to
  sharedparams = (
    f"--batch-size {args.batch_size} "
    f"--device {args.device} "
    f"--gpu-mem-limit {args.gpu_mem_limit}"
  )
  
  # determine where output should be written to
  outpref,outsuff = "","" # prefix/suffix for output writing
  if dstmode == "dir":
    outfilename = os.path.join(args.out_dir, f"{protein_name}.json")
    outsuff = f"-o {outfilename}"
  elif dstmode == "archive":
    # NB: tar --append does not work with input from stdint (-o -), therefore we have to make a 
    # little detour and write the outputs of NEFFFAST to a TMPFILE first. after that, we can
    # append the contents to the tar file and discard the TMPFILE.
    outpref = (
      "TMPFILE=$(mktemp /tmp/neff-XXXXXX); "
      "trap \"rm -f $TMPFILE\" EXIT; " # clean up tmp file after exit
      "TMPDIR=$(dirname $TMPFILE); "
      "TMPBASE=$(basename $TMPFILE); "
    )
    tarxform = f'"s|$TMPBASE|{protein_name}.json|"' # transform tmp file name to protein json
    outsuff = (
      f"-o $TMPFILE "
      f"&& tar -f {args.out_dir} --transform {tarxform} -C $TMPDIR --append $TMPBASE"
    )
  
  # determine where the input comes from and build command
  cmd = outpref
  if srcmode == "archive":
    cmd += (
      f"tar -xOf {args.source_file} {args.proteome_name}/msas/{protein_name}.a3m | "
      f"{args.neff_fast} -m - {sharedparams}"
    )
  elif srcmode == "dir":
    cmd += f"{args.neff_fast} -m {args.source_file}/{protein_name}.a3m {sharedparams}"
  else:
    raise ValueError("cannot determine command for srcmode %s" % srcmode)
  cmd += f" {outsuff}" if len(outsuff) > 0 else ""
    
  # run NEFFFAST
  res = sp.run(cmd, shell=True, capture_output=True)
  if res.returncode != 0:
    num_failed += 1
    failedfile = (
      os.path.join(args.out_dir, "failed.txt") 
      if dstmode == "dir" else 
      os.path.join(os.path.dirname(args.out_dir), "failed.txt")
    )
    with open(failedfile, "a") as f:
      f.write(protein_name + "\n")
    tqdm.write("protein %s failed due to \n%s" % (protein_name,res.stderr.decode()))
  else:
    num_success += 1

